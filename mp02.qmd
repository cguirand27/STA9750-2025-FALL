---
title: "Mini-Project 02 - Making Backyards Affordable for All"
author: "Caroline Guirand"
editor:
    mode: source
format:
    html:
        code-fold: true

---

## Introduction

A suitable introduction goes here. In this mini-project, I intend to demonstrate
my skills at Data Integration/Data Visualization/Metric Creation in an analysis of Official Statistics/Economic Data/Census Data data.

## Data Acquisition and Preparation

```{r}
# Task 1: Data Import
# ===================
# In this section, we download and prepare census data from the American Community
# Survey (ACS) covering multiple years. We focus on four key metrics that will help
# us understand housing affordability across US metro areas.

# First, we set up our data directory structure
if(!dir.exists(file.path("data", "mp02"))){
  dir.create(file.path("data", "mp02"), showWarnings=FALSE, recursive=TRUE)
}

# Override the library() function to auto-install packages if needed
# This ensures reproducibility across different environments
library <- function(pkg){
  pkg <- as.character(substitute(pkg))
  options(repos = c(CRAN = "https://cloud.r-project.org"))
  if(!require(pkg, character.only=TRUE, quietly=TRUE)) install.packages(pkg)
  stopifnot(require(pkg, character.only=TRUE, quietly=TRUE))
}

# Load required packages
library(tidyverse)   # For data manipulation and visualization
library(glue)        # For string interpolation
library(readxl)      # For reading Excel files
library(tidycensus)  # For accessing US Census Bureau data
library(httr2)       # For making HTTP requests to BLS
library(rvest)       # For web scraping BLS data

# Define helper function to download ACS data across multiple years
# This function handles caching to avoid repeated API calls
get_acs_all_years <- function(variable, geography="cbsa",
                               start_year=2009, end_year=2023){
  # Create file name for cached data
  fname <- glue("{variable}_{geography}_{start_year}_{end_year}.csv")
  fname <- file.path("data", "mp02", fname)
  
  # Only download if we don't already have the data cached
  if(!file.exists(fname)){
    YEARS <- seq(start_year, end_year)
    YEARS <- YEARS[YEARS != 2020] # Drop 2020 - No ACS 1-year survey (COVID-19)
    
    # Download data for each year and combine
    ALL_DATA <- map(YEARS, function(yy){
      tidycensus::get_acs(geography, variable, year=yy, survey="acs1") |>
        mutate(year=yy) |>
        select(-moe, -variable) |>  # Remove margin of error and variable name
        rename(!!variable := estimate)
    }) |> bind_rows()
    
    # Cache the results
    write_csv(ALL_DATA, fname)
  }
  
  # Read and return the data
  read_csv(fname, show_col_types=FALSE)
}

# Download four key data sets for Core Based Statistical Areas (CBSAs/metro areas)
# KEY OBSERVATION: All data sets share common keys: GEOID, NAME, and year
# These will be used to join the data sets together

# 1. Median household income (in 12-month inflation-adjusted dollars)
INCOME <- get_acs_all_years("B19013_001") |>
  rename(household_income = B19013_001)

# 2. Median gross rent (monthly, in dollars)
RENT <- get_acs_all_years("B25064_001") |>
  rename(monthly_rent = B25064_001)

# 3. Total population
POPULATION <- get_acs_all_years("B01003_001") |>
  rename(population = B01003_001)

# 4. Total number of households
HOUSEHOLDS <- get_acs_all_years("B11001_001") |>
  rename(households = B11001_001)
```


```{r}
# Download Building Permits Data
# ================================
# The number of new housing units permitted is not available via tidycensus,
# so we're downloading it directly from Census Bureau construction data.
# Note: Historical data (2009-2018) and current data (2019+) use different formats.

get_building_permits <- function(start_year = 2009, end_year = 2023){
  fname <- glue("housing_units_{start_year}_{end_year}.csv")
  fname <- file.path("data", "mp02", fname)
  
  if(!file.exists(fname)){
    # Process historical data (2009-2018): Fixed-width text format
    HISTORICAL_YEARS <- seq(start_year, 2018)
    
    HISTORICAL_DATA <- map(HISTORICAL_YEARS, function(yy){
      historical_url <- glue("https://www.census.gov/construction/bps/txt/tb3u{yy}.txt")
      
      # Read and parse fixed-width text file
      LINES <- readLines(historical_url)[-c(1:11)]  # Skip header lines
      
      # Extract CBSA codes (columns 5-10)
      CBSA_LINES <- str_detect(LINES, "^[[:digit:]]")
      CBSA <- as.integer(str_sub(LINES[CBSA_LINES], 5, 10))
      
      # Extract permit counts (columns 48-53)
      PERMIT_LINES <- str_detect(str_sub(LINES, 48, 53), "[[:digit:]]")
      PERMITS <- as.integer(str_sub(LINES[PERMIT_LINES], 48, 53))
      
      data_frame(CBSA = CBSA,
                 new_housing_units_permitted = PERMITS, 
                 year = yy)
    }) |> bind_rows()
    
    # Process current data (2019-2023): Excel format
    CURRENT_YEARS <- seq(2019, end_year)
    
    CURRENT_DATA <- map(CURRENT_YEARS, function(yy){
      current_url <- glue("https://www.census.gov/construction/bps/xls/msaannual_{yy}99.xls")
      
      temp <- tempfile()
      download.file(current_url, destfile = temp, mode="wb")
      
      # Try xlsx format first, fall back to xls if needed
      fallback <- function(.f1, .f2){
        function(...){
          tryCatch(.f1(...), 
                   error=function(e) .f2(...))
        }
      }
      
      reader <- fallback(read_xlsx, read_xls)
      
      reader(temp, skip=5) |>
        na.omit() |>
        select(CBSA, Total) |>
        mutate(year = yy) |>
        rename(new_housing_units_permitted = Total)
    }) |> bind_rows()
    
    # Combine historical and current data
    ALL_DATA <- rbind(HISTORICAL_DATA, CURRENT_DATA)
    
    # Cache the results
    write_csv(ALL_DATA, fname)
  }
  
  # Read and return the data
  read_csv(fname, show_col_types=FALSE)
}

# Download the permits data
# Note: CBSA is stored as a numeric code, unlike GEOID in census data
PERMITS <- get_building_permits()
```

```{r}
# Download BLS Industry Classification Codes (NAICS)
# ===================================================
# The Bureau of Labor Statistics uses the North American Industry Classification
# System (NAICS) to categorize industries. We need this lookup table to 
# understand which industries are represented in the wage data.

get_bls_industry_codes <- function(){
  fname <- file.path("data", "mp02", "bls_industry_codes.csv")
  
  if(!file.exists(fname)){
    # Download NAICS codes from BLS website
    resp <- request("https://www.bls.gov") |> 
      req_url_path("cew", "classifications", "industry", "industry-titles.htm") |>
      req_headers(`User-Agent` = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0") |> 
      req_error(is_error = \(resp) FALSE) |>
      req_perform()
    
    resp_check_status(resp)
    
    # Parse the HTML table containing NAICS codes
    naics_table <- resp_body_html(resp) |>
      html_element("#naics_titles") |> 
      html_table() |>
      mutate(title = str_trim(str_remove(str_remove(`Industry Title`, Code), "NAICS"))) |>
      select(Code, `Industry Title`) |>
      rename(title = `Industry Title`) |>
      mutate(depth = if_else(nchar(Code) <= 5, nchar(Code) - 1, NA)) |>
      filter(!is.na(depth))
    
    # Manually add codes that were presented as ranges on the website
    # (There are only three, so manual handling is easier than special-casing)
    naics_missing <- tibble::tribble(
      ~Code, ~title, ~depth, 
      "31", "Manufacturing", 1,
      "32", "Manufacturing", 1,
      "33", "Manufacturing", 1,
      "44", "Retail", 1, 
      "45", "Retail", 1,
      "48", "Transportation and Warehousing", 1, 
      "49", "Transportation and Warehousing", 1
    )
    
    naics_table <- bind_rows(naics_table, naics_missing)
    
    # Create hierarchical structure: each industry has 4 levels of detail
    # Level 1 = broad (e.g., "Manufacturing")
    # Level 4 = specific (e.g., "Semiconductor Manufacturing")
    naics_table <- naics_table |> 
      filter(depth == 4) |>  # Focus on most detailed level
      rename(level4_title=title) |> 
      mutate(level1_code = str_sub(Code, end=2), 
             level2_code = str_sub(Code, end=3), 
             level3_code = str_sub(Code, end=4)) |>
      left_join(naics_table, join_by(level1_code == Code)) |>
      rename(level1_title=title) |>
      left_join(naics_table, join_by(level2_code == Code)) |>
      rename(level2_title=title) |>
      left_join(naics_table, join_by(level3_code == Code)) |>
      rename(level3_title=title) |>
      select(-starts_with("depth")) |>
      rename(level4_code = Code) |>
      select(level1_title, level2_title, level3_title, level4_title, 
             level1_code,  level2_code,  level3_code,  level4_code) |>
      drop_na() |>
      mutate(across(contains("code"), as.integer))
    
    # Cache the results
    write_csv(naics_table, fname)
  }
  
  # Read and return the data
  read_csv(fname, show_col_types=FALSE)
}

# Download industry codes lookup table
INDUSTRY_CODES <- get_bls_industry_codes()

```

```{r}

# Download BLS Quarterly Census of Employment and Wages (QCEW)
# =============================================================
# The QCEW provides detailed employment and wage data by industry and geography.
# We use the annual averages to understand labor market conditions across CBSAs.

get_bls_qcew_annual_averages <- function(start_year=2009, end_year=2023){
  fname <- glue("bls_qcew_{start_year}_{end_year}.csv.gz")
  fname <- file.path("data", "mp02", fname)
  
  YEARS <- seq(start_year, end_year)
  YEARS <- YEARS[YEARS != 2020] # Drop 2020 to match ACS (COVID year)
  
  if(!file.exists(fname)){
    # Download and process data for each year
    ALL_DATA <- map(YEARS, .progress=TRUE, possibly(function(yy){
      fname_inner <- file.path("data", "mp02", glue("{yy}_qcew_annual_singlefile.zip"))
      
      # Download annual file if not already cached
      if(!file.exists(fname_inner)){
        request("https://www.bls.gov") |> 
          req_url_path("cew", "data", "files", yy, "csv",
                       glue("{yy}_annual_singlefile.zip")) |>
          req_headers(`User-Agent` = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0") |> 
          req_retry(max_tries=5) |>
          req_perform(fname_inner)
      }
      
      # Verify file downloaded correctly (should be ~75MB)
      if(file.info(fname_inner)$size < 755e5){
        warning(sQuote(fname_inner), " appears corrupted. Please delete and retry this step.")
      }
      
      # Read and filter the data
      read_csv(fname_inner, show_col_types=FALSE) |> 
        mutate(YEAR = yy) |>
        select(area_fips,           # Geographic identifier
               industry_code,        # NAICS industry code
               annual_avg_emplvl,    # Average employment level
               total_annual_wages,   # Total wages paid
               YEAR) |>
        # Filter to CBSAs only (FIPS starting with 'C') and valid industry codes
        filter(nchar(industry_code) <= 5,           # Keep only detailed industries
               str_starts(area_fips, "C")) |>       # Keep only CBSAs
        filter(str_detect(industry_code, "-", negate=TRUE)) |>  # Remove ranges
        # Rename for clarity
        mutate(FIPS = area_fips, 
               INDUSTRY = as.integer(industry_code), 
               EMPLOYMENT = as.integer(annual_avg_emplvl), 
               TOTAL_WAGES = total_annual_wages) |>
        select(-area_fips, -industry_code, -annual_avg_emplvl, -total_annual_wages) |>
        # Remove "all industries" aggregate (code 10)
        filter(INDUSTRY != 10) |> 
        # Calculate average wage per employee
        mutate(AVG_WAGE = TOTAL_WAGES / EMPLOYMENT)
    })) |> bind_rows()
    
    # Cache the combined results (compressed to save space)
    write_csv(ALL_DATA, fname)
  }
  
  # Read the cached data
  ALL_DATA <- read_csv(fname, show_col_types=FALSE)
  
  # Verify all years downloaded successfully
  ALL_DATA_YEARS <- unique(ALL_DATA$YEAR)
  YEARS_DIFF <- setdiff(YEARS, ALL_DATA_YEARS)
  
  if(length(YEARS_DIFF) > 0){
    stop("Download failed for the following years: ", YEARS_DIFF, 
         ". Please delete intermediate files and try again.")
  }
  
  ALL_DATA
}

# Download wage data
WAGES <- get_bls_qcew_annual_averages()
```


### Examining Dataset Structure and Identifying Join Keys
Now that we have downloaded all necessary datasets, we need to examine their structure
to identify the appropriate keys for joining them together in our analysis.

```{r}
# Examine Census Data Structure
cat("=", rep("=", 69), "\n", sep="")
cat("CENSUS DATA (from tidycensus - ACS)\n")
cat("=", rep("=", 69), "\n\n", sep="")

glimpse(INCOME)
```

The American Community Survey (ACS) provides four key data sets for our analysis. The **INCOME** data set contains `r nrow(INCOME)` observations across `r n_distinct(INCOME$GEOID)` unique Core Based Statistical Areas (CBSAs). These metro areas are tracked over `r n_distinct(INCOME$year)` years, specifically: `r paste(sort(unique(INCOME$year)), collapse=", ")`. Note that 2020 is excluded because the Census Bureau did not conduct the 1-year ACS survey that year due to the COVID-19 pandemic.

All four census data sets (INCOME, RENT, POPULATION, and HOUSEHOLDS) share the same structure with three common keys: **GEOID** (numeric CBSA identifier), **NAME** (metro area name), and **year** (survey year). These datasets can be joined directly to each other using `GEOID` and `year` as composite keys.

```{r}
# Examine Building Permits Data Structure
cat("=", rep("=", 69), "\n", sep="")
cat("BUILDING PERMITS DATA\n")
cat("=", rep("=", 69), "\n\n", sep="")

glimpse(PERMITS)
```

The **PERMITS** data set tracks new housing construction permits across `r n_distinct(PERMITS$CBSA)` CBSAs over `r n_distinct(PERMITS$year)` years (`r min(PERMITS$year)`-`r max(PERMITS$year)`). Unlike the census data, this data set includes 2020 data. The PERMITS data set uses `CBSA` as a numeric code, matching the format of `GEOID` in the census data, so we can join them directly: `GEOID == CBSA`.

```{r}
# Examine Industry Classification Data
cat("=", rep("=", 69), "\n", sep="")
cat("BLS INDUSTRY CODES (NAICS Classification)\n")
cat("=", rep("=", 69), "\n\n", sep="")

glimpse(INDUSTRY_CODES)
head(INDUSTRY_CODES %>% select(level1_title, level4_title, level4_code), 3)
```

The **INDUSTRY_CODES** data set is a lookup table containing `r nrow(INDUSTRY_CODES)` detailed industry classifications following the North American Industry Classification System (NAICS). This hierarchical system has four levels, from broad sectors (level 1) to specific industries (level 4). For example, level 1 includes broad categories like "`r INDUSTRY_CODES$level1_title[1]`" while level 4 provides specific industries like "`r INDUSTRY_CODES$level4_title[1]`". This table will be essential for understanding the wage data by industry type, joining on `level4_code == INDUSTRY`.

```{r}
# Examine BLS Wage Data Structure
cat("=", rep("=", 69), "\n", sep="")
cat("BLS QCEW WAGE DATA\n")
cat("=", rep("=", 69), "\n\n", sep="")

glimpse(WAGES)
cat("\nSample FIPS codes:", head(unique(WAGES$FIPS), 5), "\n")
```

The **WAGES** data set from the BLS Quarterly Census of Employment and Wages is our largest data set with `r format(nrow(WAGES), big.mark=",")` observations. It tracks employment and wages across `r n_distinct(WAGES$FIPS)` geographic areas, `r n_distinct(WAGES$INDUSTRY)` industries, and `r n_distinct(WAGES$YEAR)` years. 

The joining strategy here is more complex because the `FIPS` column stores CBSA codes with a "C" prefix (e.g., "C10180"). To join with census data, we need to extract the numeric portion: `as.numeric(substr(FIPS, 2, 6))`. Additionally, the year column is named `YEAR` (uppercase) rather than `year` (lowercase), so we'll need to account for this when joining.

```{r}
# Create summary table of all data sets
data_summary <- tibble(
  Dataset = c("INCOME/RENT/POPULATION/HOUSEHOLDS", "PERMITS", "WAGES", "INDUSTRY_CODES"),
  Observations = c(format(nrow(INCOME), big.mark=","), 
                   format(nrow(PERMITS), big.mark=","), 
                   format(nrow(WAGES), big.mark=","), 
                   format(nrow(INDUSTRY_CODES), big.mark=",")),
  Geographic_Units = c(n_distinct(INCOME$GEOID), 
                       n_distinct(PERMITS$CBSA), 
                       n_distinct(WAGES$FIPS), 
                       "N/A (Lookup Table)"),
  Time_Periods = c(n_distinct(INCOME$year), 
                   n_distinct(PERMITS$year), 
                   n_distinct(WAGES$YEAR), 
                   "N/A"),
  Primary_Keys = c("GEOID + year", 
                   "CBSA + year", 
                   "FIPS + YEAR + INDUSTRY", 
                   "level4_code")
)

knitr::kable(data_summary, 
             caption = "Summary of All Datasets",
             align = c('l', 'r', 'r', 'r', 'l'))
```

**Summary of Joining Strategy:**

1. **Census data sets** (INCOME, RENT, POPULATION, HOUSEHOLDS) can be joined directly on `GEOID` and `year`
2. **PERMITS** joins to census data where `GEOID == CBSA` and `year` matches  
3. **WAGES** requires extracting numeric CBSA from `FIPS` column, then joining on the converted value and matching year
4. **INDUSTRY_CODES** joins to WAGES where `INDUSTRY == level4_code` to add readable industry names

Now we can continue to combine these data sets for our YIMBY analysis. 

## Exploratory Analysis

### Entity Relationship Diagram (ERD)
To better understand the relationships between these data sets, I've created an Entity Relationship Diagram (ERD) using the DiagrammeR package. This shows the structure of each table and their relationships.

```{r}
# Install and load DiagrammeR package for creating the ERD
if(!require(DiagrammeR, quietly = TRUE)) {
  install.packages("DiagrammeR")
}
library(DiagrammeR)
```

```{r}
#| label: fig-erd-r
#| fig-cap: "Entity Relationship Diagram created with DiagrammeR"
#| fig-width: 12
#| fig-height: 10

library(DiagrammeR)

grViz("
digraph ERD {
  graph [rankdir=LR, fontname=Helvetica, bgcolor=white]
  node [shape=rectangle, style=filled, fontname=Helvetica, fontsize=10, margin=0.2]
  edge [fontname=Helvetica, fontsize=8]
  
  # Census datasets
  INCOME [label='INCOME\n━━━━━━\nGEOID (PK)\nNAME\nyear (PK)\n━━━━━━\nhousehold_income', fillcolor='#E8F4F8']
  RENT [label='RENT\n━━━━━━\nGEOID (PK)\nNAME\nyear (PK)\n━━━━━━\nmonthly_rent', fillcolor='#E8F4F8']
  POPULATION [label='POPULATION\n━━━━━━\nGEOID (PK)\nNAME\nyear (PK)\n━━━━━━\npopulation', fillcolor='#E8F4F8']
  HOUSEHOLDS [label='HOUSEHOLDS\n━━━━━━\nGEOID (PK)\nNAME\nyear (PK)\n━━━━━━\nhouseholds', fillcolor='#E8F4F8']
  
  # Other datasets
  PERMITS [label='PERMITS\n━━━━━━\nCBSA (PK)\nyear (PK)\n━━━━━━\nnew_housing_units', fillcolor='#FFF4E6']
  WAGES [label='WAGES\n━━━━━━\nFIPS (PK)\nYEAR (PK)\nINDUSTRY (PK)\n━━━━━━\nEMPLOYMENT\nTOTAL_WAGES\nAVG_WAGE', fillcolor='#F0E6FF']
  INDUSTRY_CODES [label='INDUSTRY_CODES\n━━━━━━\nlevel4_code (PK)\n━━━━━━\nlevel1-4_title\nlevel1-4_code', fillcolor='#E6F7E6']
  
  # Relationships
  INCOME -> RENT [label='GEOID+year', color='#0066CC', penwidth=2]
  INCOME -> POPULATION [label='GEOID+year', color='#0066CC', penwidth=2]
  INCOME -> HOUSEHOLDS [label='GEOID+year', color='#0066CC', penwidth=2]
  INCOME -> PERMITS [label='GEOID=CBSA\n+year', color='#FF9900', style=dashed, penwidth=2]
  INCOME -> WAGES [label='GEOID=\nsubstr(FIPS,2)\n+year=YEAR', color='#9933FF', style=dashed, penwidth=2]
  WAGES -> INDUSTRY_CODES [label='INDUSTRY=\nlevel4_code', color='#009900', penwidth=2]
}
")
```

**Key Insights from the ERD:**

The diagram reveals three distinct relationship patterns in our data:

1. **Direct Relationships (Census Data)**: The four ACS data sets (INCOME, RENT, POPULATION, HOUSEHOLDS) share identical structures with `r n_distinct(INCOME$GEOID)` CBSAs tracked over `r n_distinct(INCOME$year)` years. They can be joined directly using composite keys (`GEOID` + `year`), making them straightforward to combine.

2. **Simple Type Conversion (PERMITS)**: The building permits data uses `CBSA` as a numeric identifier, which directly matches the `GEOID` in census data. This allows for a direct join: `GEOID == CBSA`, though we must be mindful that PERMITS includes 2020 data while census data does not.

3. **Complex String Manipulation (WAGES)**: The wage data presents the most complex joining challenge. The `FIPS` column stores CBSA codes with a "C" prefix (e.g., "C10180" for Abilene, TX), requiring string extraction via `as.numeric(substr(FIPS, 2, 6))` to match with census `GEOID` values. Additionally, the year column is uppercase (`YEAR` vs `year`), necessitating careful attention during joins.

4. **Lookup Table Enhancement (INDUSTRY_CODES)**: The NAICS industry classification table serves as a hierarchical lookup, allowing us to enrich the wage data with human-readable industry names and broader sector classifications through the `INDUSTRY == level4_code` relationship.

This relationship structure will guide our data integration strategy in the following sections, where we'll progressively build a comprehensive data set combining housing affordability metrics, construction activity, and labor market conditions across US metropolitan areas.


##  Data Integration and Initial Exploration

### Task 2 Questions 

### Question 1: Largest Housing Construction (2010-2019)

**Question:** Which CBSA (by name) permitted the largest number of new housing units in the decade from 2010 to 2019 (inclusive)?
```{r}
# Filter permits data to the decade 2010-2019 and sum by CBSA
# Then joins with census data to get the readable CBSA name

q1_result <- PERMITS |>
  # Filter to the specified decade
  filter(year >= 2010, year <= 2019) |>
  # Group by CBSA and sum all permits over the decade
  group_by(CBSA) |>
  summarize(total_permits = sum(new_housing_units_permitted, na.rm = TRUE)) |>
  # Sort to find the top CBSA
  arrange(desc(total_permits)) |>
  # Take the top result
  slice(1) |>
  # Join with INCOME (or any census table) to get the CBSA name
  # Use distinct to get just one row per CBSA (since census has multiple years)
  left_join(
    INCOME |> select(GEOID, NAME) |> distinct(),
    by = c("CBSA" = "GEOID")
  )

# Display the result
q1_result
```

**Answer:** The CBSA that permitted the most new housing units between 2010 and 2019 was **`r q1_result$NAME`**, with a total of **`r format(q1_result$total_permits, big.mark=",")`** units permitted during this decade. This reflects the major population growth and housing demand this metropolitan area saw during the 2010s.

---

### Question 2: Albuquerque's Peak Construction Year

**Question:** In what year did Albuquerque, NM (CBSA Number 10740) permit the most new housing units?
```{r}
# Filter to Albuquerque CBSA and find the year with maximum permits

q2_result <- PERMITS |>
  # Filter to Albuquerque only
  filter(CBSA == 10740) |>
  # Sort by permits to find the maximum
  arrange(desc(new_housing_units_permitted)) |>
  # Take the top year
  slice(1)

# Display the result
q2_result

# Also create a visualization to see the trend and identify the artifact
albuquerque_trend <- PERMITS |>
  filter(CBSA == 10740) |>
  arrange(year)

# Show the full time series to identify any anomalies
albuquerque_trend
```

**Answer:** According to the data, Albuquerque permitted the most housing units in **`r q2_result$year`**, with **`r format(q2_result$new_housing_units_permitted, big.mark=",")`** units. 

**Important Note on COVID-19 Data Artifact:** Based on this time series, we should be cautious about this result since the year `r q2_result$year` coincides with the COVID-19 pandemic period. This might've affected data collection and reporting. If 2020 shows an unusually high value, this may represent a data quality issue rather than actual construction activity. A more reliable answer would exclude 2020 and focus on years with normal data collection: the peak non-pandemic year was **`r albuquerque_trend |> filter(year != 2020) |> arrange(desc(new_housing_units_permitted)) |> slice(1) |> pull(year)`** with **`r format(albuquerque_trend |> filter(year != 2020) |> arrange(desc(new_housing_units_permitted)) |> slice(1) |> pull(new_housing_units_permitted), big.mark=",")`** units.

---

### Question 3: Highest Average Income by State (2015)

**Question:** Which state (not CBSA) had the highest average individual income in 2015?
```{r}
# Create state lookup table for converting abbreviations to full names
state_df <- data.frame(
  abb  = c(state.abb, "DC", "PR"),
  name = c(state.name, "District of Columbia", "Puerto Rico")
)

# Calculate total income and population by state for 2015
q3_result <- INCOME |>
  # Filter to 2015 only
  filter(year == 2015) |>
  # Join with HOUSEHOLDS to get household counts
  inner_join(
    HOUSEHOLDS |> filter(year == 2015),
    by = c("GEOID", "NAME", "year")
  ) |>
  # Join with POPULATION to get total population
  inner_join(
    POPULATION |> filter(year == 2015),
    by = c("GEOID", "NAME", "year")
  ) |>
  # Extract the principal state from CBSA name
  mutate(state = str_extract(NAME, ", (.{2})", group = 1)) |>
  # Calculate total income per CBSA (household_income * households)
  mutate(total_income = household_income * households) |>
  # Group by state and sum income and population
  group_by(state) |>
  summarize(
    total_state_income = sum(total_income, na.rm = TRUE),
    total_state_population = sum(population, na.rm = TRUE)
  ) |>
  # Calculate average individual income per state
  mutate(avg_individual_income = total_state_income / total_state_population) |>
  # Join with state names for readability
  left_join(state_df, by = c("state" = "abb")) |>
  # Sort by average income
  arrange(desc(avg_individual_income)) |>
  # Take the top state
  slice(1)

# Display the result
q3_result
```

**Answer:** In 2015, **`r q3_result$name`** (state abbreviation: `r q3_result$state`) had the highest average individual income at **$`r format(round(q3_result$avg_individual_income, 2), big.mark=",", nsmall=2)`**. This was calculated by summing total household income across all CBSAs in the state (income × households) and dividing by the total population, giving us the average income per person rather than per household.

---

### Question 4: Data Scientists Employment - NYC vs San Francisco

**Question:** What is the last year in which the NYC CBSA had the most data scientists in the country?

First, we need to create a compatible CBSA code in the WAGES data to join with census data:
```{r}
# Transform BLS FIPS codes to match Census GEOID format
# BLS uses "C1234" while Census uses "12340" (numeric, with trailing 0)
WAGES_clean <- WAGES |>
  mutate(
    # Remove the "C" prefix, convert to numeric, then multiply by 10 to add trailing 0
    CBSA_code = as.numeric(str_remove(FIPS, "C")) * 10
  )

# Verify the transformation worked
cat("Sample FIPS codes from WAGES:", head(WAGES$FIPS, 3), "\n")
cat("Converted to CBSA codes:", head(WAGES_clean$CBSA_code, 3), "\n")
cat("Sample GEOID from census:", head(INCOME$GEOID, 3), "\n")
```

Now we find when NYC had the most data scientists:
```{r}
# NAICS code 5182 = Data Processing, Hosting, and Related Services
# (This is the code mentioned for data scientists and business analysts)

# Find which CBSA had the most data scientists each year
q4_result <- WAGES_clean |>
  # Filter to data scientists industry only
  filter(INDUSTRY == 5182) |>
  # For each year, find the CBSA with maximum employment
  group_by(YEAR) |>
  arrange(desc(EMPLOYMENT)) |>
  slice(1) |>
  ungroup() |>
  # Join with census data to get CBSA names
  left_join(
    INCOME |> select(GEOID, NAME) |> distinct(),
    by = c("CBSA_code" = "GEOID")
  ) |>
  # Select relevant columns for display
  select(YEAR, NAME, CBSA_code, EMPLOYMENT) |>
  arrange(YEAR)

# Display the full table
q4_result

# Find the last year NYC was on top
nyc_last_year <- q4_result |>
  filter(str_detect(NAME, "New York")) |>
  arrange(desc(YEAR)) |>
  slice(1)
```

**Answer:** Based on the analysis, the last year when the NYC CBSA had the most data scientists was **`r nyc_last_year$YEAR`**, with **`r format(nyc_last_year$EMPLOYMENT, big.mark=",")`** employees in NAICS industry 5182. After this year, San Francisco (or another CBSA) took the lead in data science employment, reflecting the tech industry's concentration on the West Coast.

The table above shows the CBSA with the most data scientists for each year in our data set, illustrating the shift in where data science jobs are concentrated.

---

### Question 5: Finance Industry Wages in NYC

**Question:** What fraction of total wages in the NYC CBSA was earned by people employed in the finance and insurance industries (NAICS code 52)? In what year did this fraction peak?
```{r}
# First, identify NYC's CBSA code
nyc_info <- INCOME |>
  filter(str_detect(NAME, "New York-Newark-Jersey City")) |>
  select(GEOID, NAME) |>
  distinct()

nyc_cbsa <- nyc_info$GEOID[1]
cat("NYC CBSA code:", nyc_cbsa, "\n")

# Calculate finance wages as fraction of total wages each year
q5_result <- WAGES_clean |>
  # Filter to NYC only
  filter(CBSA_code == nyc_cbsa) |>
  # Create indicator for finance industry (NAICS 52 = level 2 code)
  # Industry codes starting with 52 are finance
  mutate(is_finance = str_starts(as.character(INDUSTRY), "52")) |>
  # Group by year and calculate totals
  group_by(YEAR) |>
  summarize(
    finance_wages = sum(TOTAL_WAGES[is_finance], na.rm = TRUE),
    total_wages = sum(TOTAL_WAGES, na.rm = TRUE),
    finance_employment = sum(EMPLOYMENT[is_finance], na.rm = TRUE),
    total_employment = sum(EMPLOYMENT, na.rm = TRUE)
  ) |>
  # Calculate the fraction
  mutate(
    finance_wage_fraction = finance_wages / total_wages,
    finance_emp_fraction = finance_employment / total_employment
  ) |>
  arrange(YEAR)

# Display the results
q5_result

# Find the peak year
peak_year <- q5_result |>
  arrange(desc(finance_wage_fraction)) |>
  slice(1)
```

**Answer:** In the NYC CBSA, the finance and insurance industry's share of total wages peaked in **`r peak_year$YEAR`**, when it accounted for **`r round(peak_year$finance_wage_fraction * 100, 2)`%** of all wages paid in the metro area. At that time, the finance sector employed **`r round(peak_year$finance_emp_fraction * 100, 2)`%** of the workforce but earned a disproportionately large share of total wages, which is reflected in the high salaries in this industry.

Over the entire time period, the finance industry's wage share in NYC ranged from **`r round(min(q5_result$finance_wage_fraction) * 100, 2)`%** to **`r round(max(q5_result$finance_wage_fraction) * 100, 2)`%**, demonstrating the continued importance of the financial sector to New York's economy, even as its relative dominance has evolved over time.



### Task 3: Initial Visualizations

The following visualizations will help us explore housing costs, employment patterns, and household characteristics across US metropolitan areas, and therefore, better understand the relationships in our data.

### Visualization 1: Rent vs. Income Relationship (2009)

**Question:** What is the relationship between monthly rent and average household income per CBSA in 2009?
```{r}
# Join RENT and INCOME data for 2009
rent_income_2009 <- RENT |>
  filter(year == 2009) |>
  inner_join(
    INCOME |> filter(year == 2009),
    by = c("GEOID", "NAME", "year")
  ) |>
  # Remove any missing values
  filter(!is.na(monthly_rent), !is.na(household_income))

# Create the visualization
ggplot(rent_income_2009, aes(x = household_income, y = monthly_rent)) +
  # Add points with some transparency to handle over plotting
  geom_point(alpha = 0.6, color = "#2C3E50", size = 2) +
  # Add a smooth trend line to show the relationship
  geom_smooth(method = "lm", se = TRUE, color = "#E74C3C", linewidth = 1.2) +
  # Format axis labels with dollar signs and comma separators
  scale_x_continuous(
    labels = scales::dollar_format(),
    breaks = seq(0, 100000, 20000)
  ) +
  scale_y_continuous(
    labels = scales::dollar_format(),
    breaks = seq(0, 2000, 250)
  ) +
  # Add proper labels and title
  labs(
    title = "Relationship Between Household Income and Monthly Rent (2009)",
    subtitle = "Each point represents a Core Based Statistical Area (CBSA)",
    x = "Median Household Income (Annual)",
    y = "Median Monthly Gross Rent",
    caption = "Data Source: American Community Survey (ACS) 2009"
  ) +
  # Use a clean theme with larger text
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 11, color = "gray40"),
    axis.title = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  )

# Calculate correlation for narrative
correlation <- cor(rent_income_2009$household_income, 
                   rent_income_2009$monthly_rent, 
                   use = "complete.obs")
```

**Observation:** There is a strong positive relationship (correlation = `r round(correlation, 3)`) between household income and monthly rent across CBSAs in 2009. Metropolitan areas with higher median household incomes tend to have higher median rents. Areas with higher-paying jobs attract more residents, driving up housing costs. The relationship seems to be somewhat linear, despite a considerable amount of variation around the trend line. This suggests that local factors beyond income (such as housing supply, geography, and regulations) also play important roles in determining rent levels.

---

### Visualization 2: Healthcare Employment Over Time

**Question:** What is the relationship between total employment and healthcare/social services employment across CBSAs over time?
```{r}
# Prepare wage data with CBSA codes
WAGES_clean <- WAGES |>
  mutate(CBSA_code = as.numeric(str_remove(FIPS, "C")) * 10)

# Calculate total employment and healthcare employment by CBSA and year
healthcare_employment <- WAGES_clean |>
  # Healthcare and Social Services is NAICS 62 (all codes starting with 62)
  mutate(is_healthcare = str_starts(as.character(INDUSTRY), "62")) |>
  group_by(CBSA_code, YEAR) |>
  summarize(
    total_employment = sum(EMPLOYMENT, na.rm = TRUE),
    healthcare_employment = sum(EMPLOYMENT[is_healthcare], na.rm = TRUE),
    .groups = "drop"
  ) |>
  # Calculate healthcare as percentage of total
  mutate(healthcare_pct = healthcare_employment / total_employment * 100) |>
  # Filter out CBSAs with very small employment (potential data issues)
  filter(total_employment >= 10000)

# Create the visualization showing evolution over time
ggplot(healthcare_employment, 
       aes(x = total_employment, y = healthcare_employment, color = as.factor(YEAR))) +
  # Use points with transparency
  geom_point(alpha = 0.5, size = 1.5) +
  # Add a reference line showing constant healthcare share
  geom_abline(slope = 0.15, intercept = 0, linetype = "dashed", 
              color = "gray40", linewidth = 0.8) +
  # Format axes with comma separators
  scale_x_continuous(
    labels = scales::comma_format(),
    trans = "log10"  # Log scale helps show the relationship across different sized CBSAs
  ) +
  scale_y_continuous(
    labels = scales::comma_format(),
    trans = "log10"
  ) +
  # Use a color palette that shows time progression
  scale_color_viridis_d(option = "plasma", name = "Year") +
  # Add proper labels
  labs(
    title = "Healthcare Employment vs. Total Employment Across US Metro Areas",
    subtitle = "Healthcare sector consistently represents ~15% of total employment (dashed line)",
    x = "Total Employment (log scale)",
    y = "Healthcare & Social Services Employment (log scale)",
    caption = "Data Source: BLS Quarterly Census of Employment and Wages (QCEW)\nNote: CBSAs with <10,000 total employment excluded"
  ) +
  # Clean theme
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 11, color = "gray40"),
    axis.title = element_text(face = "bold"),
    legend.position = "right",
    panel.grid.minor = element_blank()
  )

# Calculate average healthcare share across all years
avg_healthcare_share <- mean(healthcare_employment$healthcare_pct, na.rm = TRUE)
```

**Observation:** Healthcare and social services employment shows a consistent relationship with total employment throughout metro areas and over time. On average, the healthcare sector accounts for approximately **`r round(avg_healthcare_share, 1)`%** of total employment across all CBSAs in our data set. The dashed reference line (representing 15% of total employment) shows that this relationship is relatively stable throughout metro areas of different sizes. The coloring by year reveals that this relationship has remained stable over time, though there may be a slight upward trend in healthcare's share of employment in recent years, reflecting the aging population and expansion of healthcare services.

---

### Visualization 3: Evolution of Household Size Over Time

**Question:** How has average household size evolved over time across different CBSAs?
```{r}
# Calculate average household size (population / households) by CBSA and year
household_size <- POPULATION |>
  inner_join(
    HOUSEHOLDS,
    by = c("GEOID", "NAME", "year")
  ) |>
  mutate(avg_household_size = population / households) |>
  # Filter out potential data errors (unrealistic household sizes)
  filter(avg_household_size > 1, avg_household_size < 5)

# Install and load gghighlight for improved visualization
library(gghighlight)

# Identify NYC and LA for highlighting
household_size_highlight <- household_size |>
  mutate(
    # Create indicator for highlighting
    highlight_metro = case_when(
      str_detect(NAME, "New York-Newark-Jersey City") ~ "New York",
      str_detect(NAME, "Los Angeles-Long Beach-Anaheim") ~ "Los Angeles",
      TRUE ~ NA_character_
    )
  )

# Create the visualization with gghighlight
ggplot(household_size_highlight, 
       aes(x = year, y = avg_household_size, group = GEOID, color = highlight_metro)) +
  geom_line(linewidth = 0.8, alpha = 0.8) +
  # Use gghighlight to automatically dim non-highlighted lines
  gghighlight(
    !is.na(highlight_metro),  # Highlight only NYC and LA
    use_direct_label = TRUE,   # Add labels directly on the lines
    label_params = list(size = 4, fontface = "bold", nudge_y = 0.05),
    unhighlighted_params = list(color = "gray80", alpha = 0.3, linewidth = 0.3)
  ) +
  # Manual colors for the highlighted metros
  scale_color_manual(
    values = c("New York" = "#E74C3C", "Los Angeles" = "#3498DB"),
    na.value = "gray80",
    name = "Highlighted Metro"
  ) +
  # Format y-axis
  scale_y_continuous(
    breaks = seq(2.0, 3.5, 0.25),
    limits = c(2.0, 3.5)
  ) +
  # Format x-axis
  scale_x_continuous(breaks = seq(2009, 2023, 2)) +
  # Add proper labels
  labs(
    title = "Evolution of Average Household Size Across US Metro Areas (2009-2023)",
    subtitle = "New York and Los Angeles highlighted; gray lines show all other CBSAs for context",
    x = "Year",
    y = "Average Household Size (Persons per Household)",
    caption = "Data Source: American Community Survey (ACS)\nNote: 2020 data unavailable due to COVID-19 survey suspension"
  ) +
  # Clean theme
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 11, color = "gray40"),
    axis.title = element_text(face = "bold"),
    legend.position = "none",  # gghighlight adds direct labels
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

# Calculate overall trend
overall_trend <- household_size |>
  group_by(year) |>
  summarize(national_avg = mean(avg_household_size, na.rm = TRUE))

start_size <- overall_trend$national_avg[1]
end_size <- overall_trend$national_avg[nrow(overall_trend)]
change_pct <- ((end_size - start_size) / start_size) * 100

# Get specific values for NYC and LA
nyc_data <- household_size_highlight |>
  filter(highlight_metro == "New York") |>
  filter(year %in% c(2009, 2023))

la_data <- household_size_highlight |>
  filter(highlight_metro == "Los Angeles") |>
  filter(year %in% c(2009, 2023))
```

**Interpretation:** Average household size has remained relatively stable across most US metro areas from 2009 to 2023, hovering around **2.5 to 2.7 persons per household**. The national average declined slightly from **`r round(start_size, 2)`** persons per household in 2009 to **`r round(end_size, 2)`** in 2023, a change of **`r round(change_pct, 1)`%**. 

By highlighting New York and Los Angeles, we can see these major metros in context:
- **New York** has maintained a household size around **`r round(mean(household_size_highlight$avg_household_size[household_size_highlight$highlight_metro == "New York"], na.rm=TRUE), 2)`** persons, slightly below the national average, reflecting its high proportion of single-person households and smaller living spaces.
- **Los Angeles** shows a household size around **`r round(mean(household_size_highlight$avg_household_size[household_size_highlight$highlight_metro == "Los Angeles"], na.rm=TRUE), 2)`** persons, slightly above the national average, typical of West Coast metros with more family-oriented housing stock.

The gray background lines provide important context: they show that while NYC and LA follow the national trend, most metros are experiencing similar declines in household size.≥ This trend has important implications for housing policy: even as population grows, the number of households grows faster, increasing housing demand beyond what raw population growth would suggest.


The visualization reveals interesting patterns:
- Most CBSAs (shown in gray) follow similar trajectories, suggesting nationwide demographic trends.
- The gap in 2020 (due to COVID-19 survey suspension) is clear.
- Major metro areas (colored lines) show some variation, with some southwestern metros maintaining slightly larger household sizes.
- The overall downward trend reflects continued demographic shifts including delayed marriage, lower birth rates, and increasing numbers of single-person households.

This trend has important implications for housing policy: even as population grows, the number of households grows faster, increasing housing demand beyond what raw population growth would suggest.


## Task 4: Rent Burden Index

In order to understand housing affordability, we need to measure the relationship between what people earn and what they pay for housing. A common measure is the **rent-to-income ratio**, which expresses monthly rent as a percentage of monthly household income.

#### Constructing the Base Metric
```{r}
# Join INCOME and RENT tables to calculate rent burden
rent_burden_raw <- INCOME |>
  inner_join(RENT, by = c("GEOID", "NAME", "year")) |>
  # Calculate monthly household income (annual income / 12)
  mutate(monthly_income = household_income / 12) |>
  # Calculate rent-to-income ratio (as a percentage)
  mutate(rent_to_income_pct = (monthly_rent / monthly_income) * 100) |>
  # Filter out any extreme outliers or missing values
  filter(!is.na(rent_to_income_pct), 
         rent_to_income_pct > 0, 
         rent_to_income_pct < 100)  # Over 100% is likely a data error

# Examine the distribution
summary(rent_burden_raw$rent_to_income_pct)
```

The rent-to-income ratio shows that metro areas typically see median households spending between **`r round(min(rent_burden_raw$rent_to_income_pct), 1)`%** and **`r round(max(rent_burden_raw$rent_to_income_pct), 1)`%** of their income on rent, with an average of **`r round(mean(rent_burden_raw$rent_to_income_pct), 1)`%**.

#### Standardization and Scaling

To create a more understandable index, we'll standardize our metric using the national average in 2009 (our baseline year) as the reference point. We'll set this baseline to **100**, making our index easy to interpret:

- **Index = 100**: Rent burden equal to 2009 national average
- **Index > 100**: Higher rent burden than 2009 baseline (less affordable)
- **Index < 100**: Lower rent burden than 2009 baseline (more affordable)
```{r}
# Calculate the 2009 national baseline (weighted by population for accuracy)
baseline_2009 <- rent_burden_raw |>
  filter(year == 2009) |>
  # Join with population to weight by metro area size
  inner_join(POPULATION |> filter(year == 2009), by = c("GEOID", "NAME", "year")) |>
  summarize(
    # Weight each CBSA's rent burden by its population
    baseline = weighted.mean(rent_to_income_pct, w = population, na.rm = TRUE)
  ) |>
  pull(baseline)

cat("2009 National Baseline Rent-to-Income Ratio:", round(baseline_2009, 2), "%\n")

# Create the standardized Rent Burden Index
rent_burden_index <- rent_burden_raw |>
  mutate(
    # Standardize to baseline = 100
    rent_burden_index = (rent_to_income_pct / baseline_2009) * 100
  ) |>
  # Add interpretive categories
  mutate(
    affordability_category = case_when(
      rent_burden_index < 80 ~ "Very Affordable",
      rent_burden_index < 95 ~ "Affordable",
      rent_burden_index < 105 ~ "Average",
      rent_burden_index < 120 ~ "Expensive",
      TRUE ~ "Very Expensive"
    ),
    affordability_category = factor(
      affordability_category,
      levels = c("Very Affordable", "Affordable", "Average", "Expensive", "Very Expensive")
    )
  )

# Summary statistics
cat("\nRent Burden Index Statistics:\n")
summary(rent_burden_index$rent_burden_index)
```

Our **Rent Burden Index** is now centered at 100 (the 2009 national average). Values above 100 indicate that renters in that metro area face higher rent burdens relative to income than the 2009 national average, while values below 100 indicate lower burdens.

#### Temporal Evolution: New York Metro Area

Let's examine how rent burden has evolved in one of America's largest and most expensive housing markets: New York City.
```{r}
# Filter to NYC metro area
nyc_rent_burden <- rent_burden_index |>
  filter(str_detect(NAME, "New York-Newark-Jersey City")) |>
  arrange(year) |>
  select(year, NAME, household_income, monthly_rent, 
         rent_to_income_pct, rent_burden_index, affordability_category)

# Create interactive table with DT
library(DT)

datatable(
  nyc_rent_burden,
  rownames = FALSE,
  options = list(
    pageLength = 15,
    dom = 't',  # Just the table, no search/pagination needed for small dataset
    ordering = TRUE
  ),
  caption = htmltools::tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 14px;',
    'Rent Burden Evolution: New York-Newark-Jersey City Metro Area (2009-2023)'
  )
) |>
  formatCurrency(c("household_income", "monthly_rent"), digits = 0) |>
  formatRound(c("rent_to_income_pct", "rent_burden_index"), digits = 1) |>
  formatStyle(
    'rent_burden_index',
    backgroundColor = styleInterval(
      cuts = c(95, 105, 120),
      values = c('#d4edda', '#fff3cd', '#f8d7da', '#f5c6cb')
    )
  )
```

**Key Findings for NYC:** The New York metro area consistently ranks as one of the most rent-burdened markets in the country. The rent burden index for NYC has `r if(tail(nyc_rent_burden$rent_burden_index, 1) > head(nyc_rent_burden$rent_burden_index, 1)) "increased" else "decreased"` from **`r round(head(nyc_rent_burden$rent_burden_index, 1), 1)`** in 2009 to **`r round(tail(nyc_rent_burden$rent_burden_index, 1), 1)`** in `r tail(nyc_rent_burden$year, 1)`, indicating that housing affordability has `r if(tail(nyc_rent_burden$rent_burden_index, 1) > head(nyc_rent_burden$rent_burden_index, 1)) "worsened" else "improved"` relative to the national baseline. Throughout this period, NYC residents have consistently spent `r round(mean(nyc_rent_burden$rent_to_income_pct), 1)`% of their household income on rent on average.

#### Most and Least Affordable Metro Areas (2023)

Now let's identify which metro areas currently have the highest and lowest rent burdens:
```{r}
# Get most recent year's data
most_recent_year <- max(rent_burden_index$year)

# Top 15 most expensive (highest rent burden)
most_expensive <- rent_burden_index |>
  filter(year == most_recent_year) |>
  arrange(desc(rent_burden_index)) |>
  select(NAME, household_income, monthly_rent, rent_to_income_pct, 
         rent_burden_index, affordability_category) |>
  head(15)

# Top 15 most affordable (lowest rent burden)
most_affordable <- rent_burden_index |>
  filter(year == most_recent_year) |>
  arrange(rent_burden_index) |>
  select(NAME, household_income, monthly_rent, rent_to_income_pct, 
         rent_burden_index, affordability_category) |>
  head(15)

# Display most expensive markets
datatable(
  most_expensive,
  rownames = FALSE,
  options = list(
    pageLength = 15,
    dom = 't',
    ordering = TRUE
  ),
  caption = htmltools::tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 14px;',
    paste0('Most Rent-Burdened Metro Areas (', most_recent_year, ')')
  )
) |>
  formatCurrency(c("household_income", "monthly_rent"), digits = 0) |>
  formatRound(c("rent_to_income_pct", "rent_burden_index"), digits = 1) |>
  formatStyle(
    'rent_burden_index',
    backgroundColor = styleInterval(
      cuts = c(120, 140, 160),
      values = c('#fff3cd', '#f8d7da', '#f5c6cb', '#721c24')
    ),
    color = styleInterval(160, c('black', 'white'))
  )
```

**Analysis of Most Expensive Markets:** The most rent-burdened metro areas in `r most_recent_year` are characterized by rent burden indices well above 100, with the top market reaching **`r round(most_expensive$rent_burden_index[1], 1)`**. These are typically:
- California coastal metros (Los Angeles, San Francisco, San Diego)
- College towns with limited housing supply
- Tourist destinations with vacation rental pressure
- Areas with restrictive zoning and NIMBY policies
```{r}
# Display most affordable markets
datatable(
  most_affordable,
  rownames = FALSE,
  options = list(
    pageLength = 15,
    dom = 't',
    ordering = TRUE
  ),
  caption = htmltools::tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 14px;',
    paste0('Most Affordable Metro Areas (', most_recent_year, ')')
  )
) |>
  formatCurrency(c("household_income", "monthly_rent"), digits = 0) |>
  formatRound(c("rent_to_income_pct", "rent_burden_index"), digits = 1) |>
  formatStyle(
    'rent_burden_index',
    backgroundColor = styleInterval(
      cuts = c(60, 70, 80),
      values = c('#155724', '#28a745', '#d4edda', '#fff3cd')
    ),
    color = styleInterval(70, c('white', 'black'))
  )
```

**Analysis of Most Affordable Markets:** The most affordable metro areas have rent burden indices significantly below 100, with the lowest at **`r round(most_affordable$rent_burden_index[1], 1)`**. These tend to be:
- Smaller metros in the Midwest and South
- Areas with abundant land and permissive zoning
- Markets with lower demand pressure
- Regions with strong local economies relative to housing costs

#### Visualization: Geographic Patterns in Rent Burden
```{r}
#| fig-width: 10
#| fig-height: 6

# Create a comparison plot showing trends in most vs least affordable
comparison_metros <- rent_burden_index |>
  filter(
    NAME %in% c(most_expensive$NAME[1:5], most_affordable$NAME[1:5])
  ) |>
  mutate(
    category = if_else(NAME %in% most_expensive$NAME[1:5], 
                       "Most Expensive (2023)", 
                       "Most Affordable (2023)"),
    short_name = str_extract(NAME, "^[^,]+")  # Extract city name before comma
  )

ggplot(comparison_metros, aes(x = year, y = rent_burden_index, 
                               color = short_name, linetype = category)) +
  geom_line(linewidth = 1) +
  geom_hline(yintercept = 100, linetype = "dashed", color = "gray40", linewidth = 0.8) +
  annotate("text", x = 2011, y = 102, label = "2009 National Average", 
           color = "gray40", size = 3) +
  scale_color_brewer(palette = "Paired", name = "Metro Area") +
  scale_linetype_manual(values = c("solid", "dashed"), name = "Category") +
  scale_y_continuous(breaks = seq(0, 200, 25)) +
  labs(
    title = "Rent Burden Index Trends: Most vs. Least Affordable Metro Areas",
    subtitle = "Index = 100 represents 2009 national average rent-to-income ratio",
    x = "Year",
    y = "Rent Burden Index",
    caption = "Data Source: American Community Survey (ACS)"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 11, color = "gray40"),
    axis.title = element_text(face = "bold"),
    legend.position = "right",
    legend.title = element_text(face = "bold", size = 10),
    panel.grid.minor = element_blank()
  )
```

**Key Insight:** The gap between the most and least affordable markets has `r if(sd(rent_burden_index$rent_burden_index[rent_burden_index$year == most_recent_year]) > sd(rent_burden_index$rent_burden_index[rent_burden_index$year == 2009])) "widened" else "narrowed"` over time. The most expensive markets have seen their rent burdens increase according to their baseline, while many affordable markets have maintained relatively stable (or even improving) affordability. This discrepancy suggests that housing policy challenges are not uniform across the country: some metros desperately need supply-side reforms (YIMBY policies), while others have maintained affordability through adequate housing construction.


## Task 5: Housing Growth Index

To identify YIMBY-friendly metros, we need to measure not just current housing construction, but whether new housing supply is keeping up with (or exceeding) population growth. A truly pro-housing metro area builds enough units to accommodate growth while also reducing the existing housing deficit.

#### Data Preparation: Calculating 5-Year Population Growth

First, we'll calculate population growth over rolling 5-year windows for each CBSA:
```{r}
# Join POPULATION and PERMITS data
# Note: PERMITS uses CBSA, POPULATION uses GEOID (both numeric, directly comparable)
housing_growth_base <- POPULATION |>
  inner_join(
    PERMITS,
    by = c("GEOID" = "CBSA", "year" = "year")
  ) |>
  arrange(GEOID, year)

# Calculate 5-year population growth using lag
housing_growth <- housing_growth_base |>
  group_by(GEOID, NAME) |>
  arrange(year) |>
  mutate(
    # Population 5 years ago
    population_5yr_ago = lag(population, n = 5),
    # Absolute population change over 5 years
    pop_change_5yr = population - population_5yr_ago,
    # Percentage population growth over 5 years
    pop_growth_rate_5yr = (pop_change_5yr / population_5yr_ago) * 100,
    # Average annual population growth
    avg_annual_pop_growth = pop_change_5yr / 5
  ) |>
  ungroup() |>
  # Filter to years where we have 5-year lookback (2014 onwards)
  filter(year >= 2014, !is.na(pop_change_5yr))

# Summary statistics
cat("Summary of 5-Year Population Growth Rates:\n")
summary(housing_growth$pop_growth_rate_5yr)
```

Starting in 2014, we can now calculate 5-year population growth for each metro area. The average CBSA grew by **`r round(mean(housing_growth$pop_growth_rate_5yr, na.rm=TRUE), 2)`%** over 5-year periods, though with substantial variation across metros.

#### Metric 1: Instantaneous Housing Supply (Per Capita Construction)

Our first metric measures the **rate of new construction relative to current population**. This captures how actively a metro is building housing regardless of whether population is growing:
```{r}
# Calculate permits per 1,000 residents
housing_growth <- housing_growth |>
  mutate(
    # New housing units per 1,000 residents
    permits_per_1000 = (new_housing_units_permitted / population) * 1000
  )

# Calculate baseline: median across all CBSA-years
baseline_permits_per_1000 <- median(housing_growth$permits_per_1000, na.rm = TRUE)

cat("Baseline permits per 1,000 residents:", round(baseline_permits_per_1000, 2), "\n")

# Create standardized index (baseline = 100)
housing_growth <- housing_growth |>
  mutate(
    construction_intensity_index = (permits_per_1000 / baseline_permits_per_1000) * 100,
    # Categorize
    construction_category = case_when(
      construction_intensity_index < 50 ~ "Very Low Construction",
      construction_intensity_index < 80 ~ "Low Construction",
      construction_intensity_index < 120 ~ "Moderate Construction",
      construction_intensity_index < 200 ~ "High Construction",
      TRUE ~ "Very High Construction"
    )
  )

cat("\nConstruction Intensity Index Statistics:\n")
summary(housing_growth$construction_intensity_index)
```

The **Construction Intensity Index** measures how many housing units are permitted based on population, with 100 representing the median rate. A metro with an index of 200 is permitting housing at twice the typical rate per capita.

#### Metric 2: Supply-Growth Balance (Construction vs Population Growth)

Our second metric compares **new housing supply to population growth**. This identifies metros that are building enough to not just accommodate growth, but potentially reduce housing scarcity:
```{r}
# Calculate housing permits based on population change
housing_growth <- housing_growth |>
  mutate(
    # Ratio of new housing units to population growth
    # Values > 1 mean building faster than population growth
    # Interpretation: housing units per new resident over 5 years
    supply_growth_ratio = (new_housing_units_permitted * 5) / pop_change_5yr
  ) |>
  # Handle special cases
  mutate(
    supply_growth_ratio = case_when(
      # Population declining but still building: very pro-housing
      pop_change_5yr <= 0 & new_housing_units_permitted > 0 ~ 
        pmax(supply_growth_ratio, 5),  # Cap at 5x for visualization
      # Population growing but no permits: anti-housing
      pop_change_5yr > 0 & new_housing_units_permitted == 0 ~ 0,
      # Normal case
      TRUE ~ supply_growth_ratio
    ),
    # Cap extreme outliers for understanding
    supply_growth_ratio_capped = pmin(supply_growth_ratio, 5)
  )

# Calculate baseline: value of 1.0 means permits = population growth
# We're using log transformation since ratio of 2 is as meaningful as ratio of 0.5
baseline_supply_growth <- 1.0  # Perfect balance

# Create standardized index (1.0 = 100, log-scaled for symmetry)
housing_growth <- housing_growth |>
  mutate(
    # Log transformation makes ratios symmetric (2x and 0.5x equally distant from 1)
    supply_balance_index = (log(supply_growth_ratio_capped) / log(baseline_supply_growth)) * 100 + 100,
    # Simpler interpretation: >100 means building faster than growth
    supply_balance_category = case_when(
      supply_balance_index < 80 ~ "Severe Undersupply",
      supply_balance_index < 95 ~ "Undersupply",
      supply_balance_index < 105 ~ "Balanced Growth",
      supply_balance_index < 120 ~ "Surplus Construction",
      TRUE ~ "High Surplus"
    )
  )

cat("Supply-Growth Balance Statistics:\n")
cat("Supply/Growth Ratio (raw):\n")
summary(housing_growth$supply_growth_ratio_capped)
cat("\nSupply Balance Index:\n")
summary(housing_growth$supply_balance_index)
```

The **Supply Balance Index** measures whether housing construction is keeping up with population growth:
- **Index = 100**: Building exactly matches population growth (1 unit per new resident)
- **Index > 100**: Building faster than population growth (reducing housing scarcity)
- **Index < 100**: Building slower than population growth (increasing housing scarcity)

#### Top Performers on Each Metric (2023)

Let's identify metros excelling on each dimension:
```{r}
# Get most recent year
most_recent_year <- max(housing_growth$year)

# Top 15 by Construction Intensity
top_construction_intensity <- housing_growth |>
  filter(year == most_recent_year) |>
  arrange(desc(construction_intensity_index)) |>
  select(NAME, population, new_housing_units_permitted, permits_per_1000, 
         construction_intensity_index) |>
  head(15)

library(DT)

datatable(
  top_construction_intensity,
  rownames = FALSE,
  options = list(pageLength = 15, dom = 't'),
  caption = htmltools::tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 14px;',
    paste0('Top 15 Metro Areas by Construction Intensity (', most_recent_year, ')')
  )
) |>
  formatCurrency("population", digits = 0) |>
  formatCurrency("new_housing_units_permitted", digits = 0, currency = "", before = FALSE) |>
  formatRound(c("permits_per_1000", "construction_intensity_index"), digits = 2) |>
  formatStyle(
    'construction_intensity_index',
    background = styleColorBar(range(top_construction_intensity$construction_intensity_index), 'lightblue'),
    backgroundSize = '100% 90%',
    backgroundRepeat = 'no-repeat',
    backgroundPosition = 'center'
  )
```

**Key Insight - Construction Intensity:** These metros are building at the highest per-capita rates. Many of them are fast-growing Sunbelt cities with permissive zoning, but the list also includes some smaller metros with particularly pro-development policies.
```{r}
# Top 15 by Supply-Growth Balance
top_supply_balance <- housing_growth |>
  filter(year == most_recent_year) |>
  arrange(desc(supply_balance_index)) |>
  select(NAME, pop_change_5yr, new_housing_units_permitted, 
         supply_growth_ratio_capped, supply_balance_index) |>
  head(15)

datatable(
  top_supply_balance,
  rownames = FALSE,
  options = list(pageLength = 15, dom = 't'),
  caption = htmltools::tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 14px;',
    paste0('Top 15 Metro Areas by Supply-Growth Balance (', most_recent_year, ')')
  )
) |>
  formatCurrency(c("pop_change_5yr", "new_housing_units_permitted"), 
                 digits = 0, currency = "", before = FALSE) |>
  formatRound(c("supply_growth_ratio_capped", "supply_balance_index"), digits = 2) |>
  formatStyle(
    'supply_balance_index',
    background = styleColorBar(range(top_supply_balance$supply_balance_index), 'lightgreen'),
    backgroundSize = '100% 90%',
    backgroundRepeat = 'no-repeat',
    backgroundPosition = 'center'
  )
```

**Key Insight - Supply Balance:** These metros are not just building, they're building faster than their populations are growing. This is the hallmark of YIMBY policy: creating enough housing to improve affordability even as the metro grows.

#### Worst Performers (Undersupplying Markets)
```{r}
# Bottom 15 by Supply-Growth Balance (most undersupplied)
worst_supply_balance <- housing_growth |>
  filter(year == most_recent_year) |>
  arrange(supply_balance_index) |>
  select(NAME, pop_change_5yr, new_housing_units_permitted, 
         supply_growth_ratio_capped, supply_balance_index) |>
  head(15)

datatable(
  worst_supply_balance,
  rownames = FALSE,
  options = list(pageLength = 15, dom = 't'),
  caption = htmltools::tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 14px;',
    paste0('Most Undersupplied Metro Areas (', most_recent_year, ')')
  )
) |>
  formatCurrency(c("pop_change_5yr", "new_housing_units_permitted"), 
                 digits = 0, currency = "", before = FALSE) |>
  formatRound(c("supply_growth_ratio_capped", "supply_balance_index"), digits = 2) |>
  formatStyle(
    'supply_balance_index',
    background = styleColorBar(range(worst_supply_balance$supply_balance_index), 'coral'),
    backgroundSize = '100% 90%',
    backgroundRepeat = 'no-repeat',
    backgroundPosition = 'center'
  )
```

**Key Insight - Undersupply:** These metros represent the housing affordability crisis. They're experiencing population growth but failing to permit enough new housing, leading to price increases and displacement.

#### Composite YIMBY Score

Finally, we combine both metrics into a single **YIMBY Score** that captures both construction intensity and supply-growth balance:
```{r}
# Create composite score as weighted average
# Weight construction intensity 40%, supply balance 60%
# Reasoning: Keeping up with growth (balance) is more important than raw volume
housing_growth <- housing_growth |>
  mutate(
    yimby_score = (0.4 * construction_intensity_index) + 
                  (0.6 * supply_balance_index),
    yimby_category = case_when(
      yimby_score < 80 ~ "Anti-Housing (NIMBY)",
      yimby_score < 95 ~ "Below Average",
      yimby_score < 105 ~ "Average",
      yimby_score < 120 ~ "Pro-Housing",
      TRUE ~ "Highly Pro-Housing (YIMBY)"
    )
  )

# Top 20 YIMBY metros
top_yimby_metros <- housing_growth |>
  filter(year == most_recent_year) |>
  arrange(desc(yimby_score)) |>
  select(NAME, population, new_housing_units_permitted, 
         construction_intensity_index, supply_balance_index, yimby_score, yimby_category) |>
  head(20)

datatable(
  top_yimby_metros,
  rownames = FALSE,
  options = list(pageLength = 20, dom = 't'),
  caption = htmltools::tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 14px;',
    paste0('Top 20 Most YIMBY-Friendly Metro Areas (', most_recent_year, ')')
  )
) |>
  formatCurrency("population", digits = 0) |>
  formatCurrency("new_housing_units_permitted", digits = 0, currency = "", before = FALSE) |>
  formatRound(c("construction_intensity_index", "supply_balance_index", "yimby_score"), 
              digits = 1) |>
  formatStyle(
    'yimby_score',
    background = styleColorBar(range(top_yimby_metros$yimby_score), 'lightgreen'),
    backgroundSize = '100% 90%',
    backgroundRepeat = 'no-repeat',
    backgroundPosition = 'center'
  ) |>
  formatStyle(
    'yimby_category',
    backgroundColor = styleEqual(
      levels = c("Anti-Housing (NIMBY)", "Below Average", "Average", 
                 "Pro-Housing", "Highly Pro-Housing (YIMBY)"),
      values = c('#f8d7da', '#fff3cd', '#d1ecf1', '#d4edda', '#28a745')
    )
  )
```

**America's Most YIMBY Cities:** The top YIMBY metros in `r most_recent_year` share common characteristics:
- **Permissive zoning**: Fewer restrictions on what and where to build
- **Available land**: Room to expand, often in Sunbelt locations
- **Pro-growth policies**: Local governments that welcome development
- **Economic dynamism**: Growing job markets attracting new residents
- **Political will**: Leadership committed to housing affordability

The winner, **`r top_yimby_metros$NAME[1]`**, achieved a YIMBY score of **`r round(top_yimby_metros$yimby_score[1], 1)`**, demonstrating exceptional commitment to housing supply.

#### Visualization: YIMBY Score Distribution
```{r}
#| fig-width: 10
#| fig-height: 6

# Create scatter plot showing both dimensions
plot_data <- housing_growth |>
  filter(year == most_recent_year, population >= 100000)  # Focus on larger metros

ggplot(plot_data, aes(x = construction_intensity_index, y = supply_balance_index, 
                      size = population, color = yimby_category)) +
  geom_point(alpha = 0.6) +
  # Add reference lines at average (100)
  geom_hline(yintercept = 100, linetype = "dashed", color = "gray40") +
  geom_vline(xintercept = 100, linetype = "dashed", color = "gray40") +
  # Add quadrant labels
  annotate("text", x = 50, y = 150, label = "Low Volume,\nHigh Balance", 
           color = "gray50", size = 3) +
  annotate("text", x = 150, y = 150, label = "High Volume,\nHigh Balance\n(YIMBY)", 
           color = "darkgreen", size = 3.5, fontface = "bold") +
  annotate("text", x = 50, y = 50, label = "Low Volume,\nLow Balance\n(NIMBY)", 
           color = "darkred", size = 3.5, fontface = "bold") +
  annotate("text", x = 150, y = 50, label = "High Volume,\nLow Balance", 
           color = "gray50", size = 3) +
  # Styling
  scale_size_continuous(range = c(2, 12), labels = scales::comma, name = "Population") +
  scale_color_manual(
    values = c("Anti-Housing (NIMBY)" = "#dc3545", 
               "Below Average" = "#ffc107",
               "Average" = "#17a2b8",
               "Pro-Housing" = "#28a745",
               "Highly Pro-Housing (YIMBY)" = "#155724"),
    name = "YIMBY Category"
  ) +
  labs(
    title = "The YIMBY Landscape: Construction Intensity vs. Supply-Growth Balance",
    subtitle = paste0("Metro areas with population > 100,000 (", most_recent_year, ")"),
    x = "Construction Intensity Index\n(Housing permits per capita, 100 = median)",
    y = "Supply-Growth Balance Index\n(Construction vs. population growth, 100 = balanced)",
    caption = "Data Sources: US Census Bureau Building Permits Survey & American Community Survey\nTop-right quadrant represents ideal YIMBY policies: high construction that exceeds population growth"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 11, color = "gray40"),
    axis.title = element_text(face = "bold"),
    legend.position = "right",
    panel.grid.minor = element_blank()
  )
```

**Observation:** The ideal YIMBY metros appear in the **top-right quadrant**: high construction intensity *and* building faster than population growth. These are the cities successfully addressing housing affordability through supply-side policies. Conversely, metros in the **bottom-left quadrant** face the steepest challenges: low construction despite population growth, a recipe for affordability crises.


## Task 6: Identifying YIMBY Success Stories

The true test of YIMBY policies is not just building housing, but doing so in a way that improves affordability in growing metros. We're now combining our Rent Burden and Housing Growth metrics to identify cities that have successfully addressed housing challenges.

#### Defining YIMBY Success

A successful YIMBY city must demonstrate:
1. **Initial affordability challenge**: High rent burden in the early study period (2009-2014)
2. **Affordability improvement**: Declining rent burden over time
3. **Economic vitality**: Population growth (not just cheap due to decline)
4. **Pro-housing policies**: Above-average housing construction relative to growth

#### Data Preparation: Combining Metrics
```{r}
# Combine rent burden and housing growth metrics
# Start with rent burden for all years
yimby_analysis <- rent_burden_index |>
  select(GEOID, NAME, year, household_income, monthly_rent, 
         rent_to_income_pct, rent_burden_index, affordability_category)

# Add housing growth metrics (available 2014+)
yimby_analysis <- yimby_analysis |>
  left_join(
    housing_growth |> 
      select(GEOID, year, population, new_housing_units_permitted,
             pop_change_5yr, pop_growth_rate_5yr, permits_per_1000,
             construction_intensity_index, supply_balance_index, yimby_score),
    by = c("GEOID", "year")
  )

# Calculate key metrics for identifying YIMBY success
yimby_metrics <- yimby_analysis |>
  group_by(GEOID, NAME) |>
  arrange(year) |>
  summarize(
    # Criterion 1: Initial rent burden (average 2009-2014)
    early_rent_burden = mean(rent_burden_index[year >= 2009 & year <= 2014], na.rm = TRUE),
    
    # Criterion 2: Change in rent burden (2014 to most recent year with data)
    initial_rent_burden = rent_burden_index[year == 2014][1],
    final_rent_burden = rent_burden_index[year == max(year)][1],
    rent_burden_change = final_rent_burden - initial_rent_burden,
    rent_burden_pct_change = (rent_burden_change / initial_rent_burden) * 100,
    
    # Criterion 3: Population growth (2014 to most recent)
    initial_population = population[year == 2014][1],
    final_population = population[year == max(year)][1],
    total_pop_growth = final_population - initial_population,
    pop_growth_pct = (total_pop_growth / initial_population) * 100,
    
    # Criterion 4: Average housing growth metrics (2014+)
    avg_yimby_score = mean(yimby_score[year >= 2014], na.rm = TRUE),
    avg_construction_intensity = mean(construction_intensity_index[year >= 2014], na.rm = TRUE),
    avg_supply_balance = mean(supply_balance_index[year >= 2014], na.rm = TRUE),
    
    # Additional context
    final_year = max(year),
    
    .groups = "drop"
  ) |>
  # Remove metros with insufficient data
  filter(!is.na(early_rent_burden), 
         !is.na(rent_burden_change),
         !is.na(pop_growth_pct),
         !is.na(avg_yimby_score))

# Identify YIMBY success stories based on all 4 criteria
yimby_success <- yimby_metrics |>
  mutate(
    # Criterion 1: High initial burden (above 105)
    had_high_burden = early_rent_burden > 105,
    
    # Criterion 2: Rent burden decreased (negative change)
    burden_decreased = rent_burden_change < 0,
    
    # Criterion 3: Population grew (positive growth)
    population_grew = pop_growth_pct > 0,
    
    # Criterion 4: Above-average housing growth (YIMBY score > 100)
    strong_housing_growth = avg_yimby_score > 100,
    
    # Count criteria met
    criteria_met = had_high_burden + burden_decreased + population_grew + strong_housing_growth,
    
    # Classify metros
    yimby_classification = case_when(
      criteria_met == 4 ~ "YIMBY Success Story",
      criteria_met == 3 & strong_housing_growth ~ "Emerging YIMBY",
      criteria_met >= 2 & population_grew ~ "Mixed Results",
      population_grew == FALSE ~ "Declining/Stagnant",
      TRUE ~ "NIMBY Challenge"
    )
  )

# Summary of classifications
cat("YIMBY Classification Summary:\n")
table(yimby_success$yimby_classification)
```

We identified **`r sum(yimby_success$yimby_classification == "YIMBY Success Story")`** metros that meet all four YIMBY success criteria, demonstrating that pro-housing policies can improve affordability even in growing dynamic cities economically.

#### Visualization 1: The YIMBY Success Quadrant

This visualization plots rent burden change against housing growth, with bubble size representing population growth:
```{r}
#| fig-width: 12
#| fig-height: 8

# Create scatter plot showing relationship between rent burden change and housing growth
# Filter to metros with population > 100,000 for clarity
plot_data <- yimby_success |>
  filter(final_population >= 100000) |>
  mutate(
    pop_size_category = cut(final_population, 
                            breaks = c(0, 250000, 500000, 1000000, Inf),
                            labels = c("<250K", "250K-500K", "500K-1M", ">1M"))
  )

ggplot(plot_data, aes(x = avg_yimby_score, y = rent_burden_change, 
                      size = pop_growth_pct, color = yimby_classification)) +
  # Add reference lines
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray40", linewidth = 0.8) +
  geom_vline(xintercept = 100, linetype = "dashed", color = "gray40", linewidth = 0.8) +
  
  # Add quadrant labels
  annotate("rect", xmin = 100, xmax = Inf, ymin = -Inf, ymax = 0,
           alpha = 0.1, fill = "green") +
  annotate("text", x = 130, y = -15, 
           label = "YIMBY SUCCESS\n(High construction,\nimproving affordability)", 
           color = "darkgreen", size = 4, fontface = "bold") +
  
  annotate("text", x = 70, y = -15, 
           label = "Declining Markets\n(Improving affordability\ndue to population loss)", 
           color = "gray50", size = 3) +
  
  annotate("text", x = 130, y = 15, 
           label = "Building but\nNot Enough\n(Construction failing\nto improve affordability)", 
           color = "orange", size = 3) +
  
  annotate("text", x = 70, y = 15, 
           label = "NIMBY Crisis\n(Low construction,\nworsening affordability)", 
           color = "darkred", size = 3.5, fontface = "bold") +
  
  # Points
  geom_point(alpha = 0.7) +
  
  # Styling
  scale_size_continuous(
    range = c(3, 15), 
    labels = scales::percent_format(scale = 1),
    name = "Population Growth %"
  ) +
  scale_color_manual(
    values = c(
      "YIMBY Success Story" = "#28a745",
      "Emerging YIMBY" = "#5cb85c",
      "Mixed Results" = "#ffc107",
      "Declining/Stagnant" = "#6c757d",
      "NIMBY Challenge" = "#dc3545"
    ),
    name = "Classification"
  ) +
  scale_x_continuous(breaks = seq(60, 160, 20)) +
  scale_y_continuous(breaks = seq(-30, 30, 10)) +
  
  labs(
    title = "The YIMBY Success Landscape: Housing Growth vs. Affordability Improvement",
    subtitle = "Metro areas with population > 100,000 (2014-2023)",
    x = "Average YIMBY Score (2014-2023)\n← Less Construction | More Construction →",
    y = "Change in Rent Burden Index (2014-2023)\n← More Affordable | Less Affordable →",
    caption = "Data Sources: US Census Bureau & American Community Survey\nGreen quadrant (top-right) shows ideal outcome: high housing construction improving affordability in growing metros"
  ) +
  
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 15),
    plot.subtitle = element_text(size = 11, color = "gray40"),
    axis.title = element_text(face = "bold", size = 11),
    legend.position = "right",
    panel.grid.minor = element_blank()
  )
```

**Observation:** The green-shaded quadrant (upper-right) represents the **YIMBY success zone**: metros with above-average housing construction that have seen rent burden *decrease* over time. The size of bubbles shows population growth, confirming these are economically vibrant areas, not cities declining into affordability. The lower-left quadrant shows the opposite: NIMBY metros with low construction and worsening affordability crises.

#### Visualization 2: YIMBY Success Stories Over Time

Let's examine how rent burden has evolved in the most successful YIMBY metros:
```{r}
#| fig-width: 12
#| fig-height: 8

# Identify top 10 YIMBY success stories
top_yimby_success <- yimby_success |>
  filter(yimby_classification == "YIMBY Success Story") |>
  arrange(desc(avg_yimby_score), rent_burden_change) |>
  head(10)

# Get time series for these metros
yimby_success_timeseries <- yimby_analysis |>
  filter(GEOID %in% top_yimby_success$GEOID) |>
  mutate(
    short_name = str_extract(NAME, "^[^,]+")  # Extract city name
  )

# Also get some NIMBY comparison metros (high burden, got worse, growing population)
nimby_comparison <- yimby_success |>
  filter(early_rent_burden > 105,  # Started with high burden
         rent_burden_change > 5,    # Got worse
         pop_growth_pct > 5,        # Still growing
         final_population >= 500000) |>  # Large metros
  arrange(desc(rent_burden_change)) |>
  head(5)

nimby_timeseries <- yimby_analysis |>
  filter(GEOID %in% nimby_comparison$GEOID) |>
  mutate(short_name = str_extract(NAME, "^[^,]+"))

# Combine for visualization
comparison_data <- bind_rows(
  yimby_success_timeseries |> mutate(category = "YIMBY Success"),
  nimby_timeseries |> mutate(category = "NIMBY Comparison")
)

library(gghighlight)

ggplot(comparison_data, aes(x = year, y = rent_burden_index, 
                            group = GEOID, color = category)) +
  geom_line(linewidth = 1.2, alpha = 0.8) +
  geom_hline(yintercept = 100, linetype = "dashed", color = "gray40", linewidth = 0.8) +
  annotate("text", x = 2010, y = 102, label = "2009 National Average", 
           color = "gray40", size = 3) +
  
  # Use faceting to separate YIMBY vs NIMBY
  facet_wrap(~category, ncol = 1) +
  
  # Styling
  scale_color_manual(
    values = c("YIMBY Success" = "#28a745", "NIMBY Comparison" = "#dc3545"),
    name = "Policy Approach"
  ) +
  scale_y_continuous(breaks = seq(80, 160, 20)) +
  scale_x_continuous(breaks = seq(2009, 2023, 2)) +
  
  labs(
    title = "YIMBY Success vs. NIMBY Failure: Rent Burden Trajectories (2009-2023)",
    subtitle = "Top 10 YIMBY metros show improving affordability despite growth; NIMBY metros show worsening crisis",
    x = "Year",
    y = "Rent Burden Index\n(100 = 2009 National Average)",
    caption = "Data Source: American Community Survey\nYIMBY metros combined high housing construction with population growth and declining rent burden"
  ) +
  
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 11, color = "gray40"),
    axis.title = element_text(face = "bold"),
    legend.position = "top",
    strip.text = element_text(face = "bold", size = 12),
    strip.background = element_rect(fill = "gray90", color = NA),
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

**Observation:** This comparison frankly illustrates the impact of housing policy. The top panel shows YIMBY success stories: metros that started with high rent burdens but have seen steady improvement through aggressive housing construction. The bottom panel shows NIMBY metros: despite (or because of) similar growth pressures, these cities have failed to build adequate housing, resulting in worsening affordability crises.

#### The YIMBY Success Honor Roll

Here are the metros that successfully met all four YIMBY criteria:
```{r}
# Create detailed table of YIMBY success stories
yimby_success_table <- yimby_success |>
  filter(yimby_classification == "YIMBY Success Story") |>
  arrange(desc(avg_yimby_score)) |>
  select(NAME, early_rent_burden, final_rent_burden, rent_burden_change,
         pop_growth_pct, avg_yimby_score) |>
  mutate(
    early_rent_burden = round(early_rent_burden, 1),
    final_rent_burden = round(final_rent_burden, 1),
    rent_burden_change = round(rent_burden_change, 1),
    pop_growth_pct = round(pop_growth_pct, 1),
    avg_yimby_score = round(avg_yimby_score, 1)
  )

library(DT)

datatable(
  yimby_success_table,
  rownames = FALSE,
  colnames = c("Metro Area", "Initial Rent Burden\n(2009-2014 Avg)", 
               "Current Rent Burden", "Burden Change", 
               "Population Growth %", "Avg YIMBY Score"),
  options = list(
    pageLength = 20,
    order = list(list(5, 'desc')),  # Sort by YIMBY score
    dom = 'tp'
  ),
  caption = htmltools::tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 14px;',
    'YIMBY Success Stories: Metros Meeting All Four Criteria'
  )
) |>
  formatStyle(
    'rent_burden_change',
    background = styleInterval(c(-10, -5, 0), c('#155724', '#28a745', '#d4edda', '#fff3cd')),
    color = styleInterval(-10, c('white', 'black'))
  ) |>
  formatStyle(
    'avg_yimby_score',
    background = styleColorBar(range(yimby_success_table$avg_yimby_score), '#28a745'),
    backgroundSize = '100% 90%',
    backgroundRepeat = 'no-repeat',
    backgroundPosition = 'center'
  )
```

**Key Findings:** These **`r nrow(yimby_success_table)`** metro areas demonstrate that pro-housing policies work. Common characteristics include:

1. **Permissive zoning**: Allowing multi-family housing and reducing parking requirements
2. **Streamlined permitting**: Faster approval processes reduce construction costs
3. **Political will**: Local leadership prioritizing affordability over NIMBYism
4. **Available land**: Room to expand, particularly in Sunbelt locations
5. **Economic growth**: Strong job markets creating demand for housing

The leader, **`r yimby_success_table$NAME[1]`**, achieved an average YIMBY score of **`r yimby_success_table$avg_yimby_score[1]`** while reducing rent burden by **`r abs(yimby_success_table$rent_burden_change[1])` points** and growing its population by **`r yimby_success_table$pop_growth_pct[1]`%**. This is the model other metros should follow.

#### Policy Implications

The existence of YIMBY success stories proves that housing affordability crises are not inevitable. Cities can grow, remain economically vibrant, and *improve* affordability simultaneously, but only if they embrace supply-side housing policies. The alternative, visible in NIMBY metros, is a vicious cycle: restricted supply drives up prices, which increases political pressure for rent control and other demand-side interventions that further discourage construction.

For federal policymakers considering YIMBY incentive programs, these success stories provide compelling evidence: **housing supply matters**, and cities that build housing see real affordability improvements.










Code related to Exploratory Data Analysis goes here. This may include
exploratory graphics, instructor-provided exploratory questions, or other
similar elements. 

## Final Insights and Deliverable

Code related to the final deliverable of the assignment goes here. 



------------------------------------------------------------------------

This work ©2025 by cguirand27 was initially prepared as a Mini-Project for
STA 9750 at Baruch College. More details about this course can be found at
[the course site](https://michael-weylandt.com/STA9750) and instructions for
this assignment can be found at 
[MP #02](https://michael-weylandt.com/STA9750/miniprojects/mini02.html)
